import { ContextEntry } from "./types";

/**
 * Generate a markdown prompt from context entries.
 * 
 * Uses the LATEST entry for task/state/next steps, but MERGES decisions and
 * approaches from the last 3 entries (deduplicated). This prevents knowledge
 * loss when a low-quality auto-save overwrites a rich manual save â€” the
 * decisions and approaches from earlier sessions survive.
 */
export function generatePrompt(entries: ContextEntry[]): string {
  if (entries.length === 0) return "No context found for this branch.";

  const latest = entries[entries.length - 1];
  const timeAgo = getTimeAgo(latest.timestamp);

  // Merge approaches and decisions from the last 3 entries (deduplicated)
  const recentEntries = entries.slice(-3);
  const mergedApproaches = dedup(recentEntries.flatMap((e) => e.approaches));
  const mergedDecisions = dedup(recentEntries.flatMap((e) => e.decisions));
  const mergedBlockers = dedup(recentEntries.flatMap((e) => e.blockers || []));

  let prompt = `## Project Context (auto-generated by Valyrian Context)\n\n`;
  prompt += `**Repo:** ${latest.repo}\n`;
  prompt += `**Branch:** ${latest.branch}\n`;
  prompt += `**Last session:** ${timeAgo}\n`;
  prompt += `**Author:** ${latest.author}\n\n`;

  prompt += `### Current Task\n${latest.task}\n\n`;

  if (latest.goal) {
    prompt += `### Goal\n${latest.goal}\n\n`;
  }

  if (mergedApproaches.length > 0) {
    prompt += `### What's Been Tried\n`;
    mergedApproaches.forEach((a) => (prompt += `- ${a}\n`));
    prompt += `\n`;
  }

  if (mergedDecisions.length > 0) {
    prompt += `### Key Decisions\n`;
    mergedDecisions.forEach((d) => (prompt += `- ${d}\n`));
    prompt += `\n`;
  }

  prompt += `### Current State\n${latest.currentState}\n\n`;

  if (latest.nextSteps.length > 0) {
    prompt += `### Next Steps\n`;
    latest.nextSteps.forEach((s, i) => (prompt += `${i + 1}. ${s}\n`));
    prompt += `\n`;
  }

  if (mergedBlockers.length > 0) {
    prompt += `### Blockers\n`;
    mergedBlockers.forEach((b) => (prompt += `- ${b}\n`));
    prompt += `\n`;
  }

  if (latest.filesChanged.length > 0) {
    prompt += `### Files Changed Recently\n`;
    latest.filesChanged.forEach((f) => (prompt += `- ${f}\n`));
    prompt += `\n`;
  }

  if (latest.recentCommits.length > 0) {
    prompt += `### Recent Commits\n`;
    latest.recentCommits.forEach((c) => (prompt += `- ${c}\n`));
    prompt += `\n`;
  }

  // Add history summary if multiple sessions
  if (entries.length > 1) {
    prompt += `### Session History (${entries.length} sessions)\n`;
    entries
      .slice(-5)
      .reverse()
      .forEach((e) => {
        prompt += `- [${new Date(e.timestamp).toLocaleString()}] ${e.task}\n`;
      });
    prompt += `\n`;
  }

  if (latest.handoffNote) {
    prompt += `### Handoff Note\n${latest.handoffNote}\n\n`;
  }

  return prompt;
}

/**
 * Deduplicate strings by lowercase comparison, preserving first occurrence's casing.
 */
function dedup(items: string[]): string[] {
  const seen = new Set<string>();
  return items.filter((item) => {
    const key = item.toLowerCase().trim();
    if (!key || seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

function getTimeAgo(timestamp: string): string {
  const diff = Date.now() - new Date(timestamp).getTime();
  const minutes = Math.floor(diff / 60000);
  if (minutes < 60) return `${minutes} minutes ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours} hours ago`;
  const days = Math.floor(hours / 24);
  return `${days} days ago`;
}
